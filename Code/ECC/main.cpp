#include <cstdlib>
#include <iostream>
#include <vector>
#include <openssl/crypto.h>
#include <openssl/bn.h>
#include "constants.hpp"

using namespace std;

#include <math.h>
#include "FiniteFieldElement.hpp"

// BIGNUM * int
// FiniteFieldElement<P> operator*(BIGNUM* lhs, int n)
// {
//     BIGNUM* tmp2 = BN_new();
//     BN_set_word(tmp2, n); 

//     BN_CTX *ctx = BN_CTX_new();
//     BIGNUM* tmp = BN_new();
//     BN_mul(tmp, lhs, tmp2, ctx);
//     return FiniteFieldElement<P>( tmp );
// }
// // int * BIGNUM
// FiniteFieldElement<P> operator*(int n, BIGNUM* rhs)
// {
//     BIGNUM* tmp2 = BN_new();
//     BN_set_word(tmp2, n); 

//     BN_CTX *ctx = BN_CTX_new();
//     BIGNUM* tmp = BN_new();
//     BN_mul(tmp, tmp2, rhs, ctx);
//     return FiniteFieldElement<P>( tmp );
// }

namespace Crypto
{
    /*
        Elliptic Curve over a finite field of order P:
        
        y^2 mod P = x^3 + ax + b mod P
                
        Template parameter P is the order of the finite field Fp over which this curve is defined
    */

//    template<BIGNUM* P>
   class EllipticCurve
   {
        public:
            // this curve is defined over the finite field (Galois field) Fp, this is the 
            // typedef of elements in it
            typedef FiniteFieldElement ffe_t;

        /*
            A point, or group element, on the EC, consisting of two elements of the field FP
            Points can only created by the EC instance itself as they have to be 
            elements of the group generated by the EC
        */
        class Point
        {
            friend class EllipticCurve;
            ffe_t  x_;
            ffe_t  y_;
            EllipticCurve *ec_;

            void   addDouble(int m, Point& acc)
            {        
                if ( m > 0 )
                {       
                    Point r = acc; 
                    for ( int n=0; n < m; ++n )
                    {
                        r += r;     // doubling step                          
                    }
                    acc = r;
                }        
            }
            // doubling multiplier algorithm
            // multiplies a by k by expanding in multiplies by 2
            // a is also an accumulator that stores the intermediate results
            // between the "1s" of the binary form of the input scalar k
            Point scalarMultiply(BIGNUM* k, const Point& a)
            {
                Point acc = a;
                Point res = Point(0,0,*ec_);
                int i = 0, j = 0;
                string b = BN_bn2dec(k);
                int n = b.size();
                
                while( n > 0 )
                {
                    if ( b[n-1] == '1' )
                    {
                        // bit is set; acc = 2^(i-j)*acc
                        addDouble(i-j,acc);
                        res += acc;           
                        j = i;  // last bit set
                    }
                    n--;
                    if(n == 0)break;
                    b = b.substr(0, n);
                    ++i;
                }
                return res;
            }

            // adding two points on the curve
            void add(ffe_t x1, ffe_t y1, ffe_t x2, ffe_t y2, ffe_t& xR, ffe_t& yR) const
            {
                // Addition with Identity Element
                if ( x1 == 0 && y1 == 0 ) 
                {
                    xR = x2;
                    yR = y2;
                    return;
                }
                if ( x2 == 0 && y2 == 0 )
                {
                    xR = x1;
                    yR = y1;
                    return;
                }
                // Symmetric
                if ( y1 == -y2 ) 
                {
                    
                    xR = 0;
                    yR = 0; // Vertical Line
                    return;
                }

                ffe_t s; // Slope of the line passing through (x1,y1), (x2, y2)
                if ( x1 == x2 && y1 == y2 )
                {
                    //2P
                    // Desired expression can be obtained by solving for tangent on x1
                    // s = (3*(x1.i()*x1.i()) + ec_->a()) / (2*y1);
                    s = (3*(x1*x1) + ec_->a()) / (2*y1);
                    xR = ((s*s) - 2*x1);                            
                }
                else
                {   
                    //P+Q
                    s = (y1 - y2) / (x1 - x2);
                    xR = ((s*s) - x1 - x2);

                    
                }

                if ( s != 0 )
                {
                    yR = (-y1 + s*(x1 - xR));  // We have to use this formula for yR calculation
                                               // Reference -> https://asecuritysite.com/encryption/ecc_points_add3
                                               // We have to find the 3rd point and then take its negative i.e. Reflection aroundn X-axis
                    // yR = (y1 - s*(x1 - xR)); // Using  (y-y1) = m*(x-x1)

                }
                else
                {
                    // xR = yR = 0;
                    yR = y1;
                }
            }

            Point(BIGNUM* x, BIGNUM* y) : x_(x),y_(y)/*,ec_(BN_ZERO, BN_ZERO)*/
            {}

            Point(int x, int y) : x_(x), y_(y)
            {}

            Point(BIGNUM* x, BIGNUM* y, EllipticCurve & EllipticCurve) : x_(x), y_(y),ec_(&EllipticCurve)
            {}

            Point(int x, int y, EllipticCurve & EllipticCurve) : x_(x), y_(y),ec_(&EllipticCurve)
            {}

            Point(const ffe_t& x, const ffe_t& y, EllipticCurve & EllipticCurve): x_(x),y_(y),ec_(&EllipticCurve)
            {}

            Point(const ffe_t& x, const ffe_t& y): x_(x),y_(y)
            {}

            public:                    
                static  Point   ONE;
                
                // copy ctor
                Point(const Point& rhs)
                {
                    x_ = rhs.x_;
                    y_ = rhs.y_;
                    ec_ = rhs.ec_;
                }
                // assignment
                Point& operator=(const Point& rhs)
                {
                    x_ = rhs.x_;
                    y_ = rhs.y_;
                    ec_ = rhs.ec_;
                    return *this;
                }
                // access x component as element of Fp
                ffe_t x() const { return x_; }
                // access y component as element of Fp
                ffe_t y() const { return y_; }
            
                // calculate the order of this point by brute-force additions
                // WARNING: this can be VERY slow if the period is long and might not even converge 
                // so maxPeriod should probably be set to something sensible...
                unsigned int     PointOrder(unsigned int maxPeriod = 1000) const
                {
                    Point r = *this;
                    unsigned int n = 0;
                    while( r.x_ != 0 && r.y_ != 0 )
                    {
                        ++n;
                        r += *this;
                        if ( n > maxPeriod ) break;
                    }
                    return n;
                }

                // negate
                Point   operator-()
                {
                    return Point(x_,-y_);
                }                                        
                // ==
                friend bool    operator==(const Point& lhs, const Point& rhs)
                {
                    return (lhs.ec_ == rhs.ec_) && (lhs.x_ == rhs.x_) && (lhs.y_ == rhs.y_);
                }
                // !=
                friend bool    operator!=(const Point& lhs, const Point& rhs)
                {
                    return (lhs.ec_ != rhs.ec_) || (lhs.x_ != rhs.x_) || (lhs.y_ != rhs.y_);
                }

                // a + b         
                friend Point operator+(const Point& lhs, const Point& rhs)
                {       
                    ffe_t xR, yR;
                    lhs.add(lhs.x_,lhs.y_,rhs.x_,rhs.y_,xR,yR);
                    return Point(xR,yR,*lhs.ec_);    
                }
                // BIGNUM * a
                friend  Point operator*(BIGNUM* k, const Point& rhs)
                {
                    return Point(rhs).operator*=(k);
                }
                // +=
                Point& operator+=(const Point& rhs)
                {   
                    add(x_,y_,rhs.x_,rhs.y_,x_,y_);
                    return *this;  
                }
                // a *= BIGNUM
                Point& operator*=(BIGNUM* k)
                {
                    return (*this = scalarMultiply(k,*this));
                }                    
                // ostream handler: print this point
                friend ostream& operator <<(ostream& os, const Point& p)
                {
                    return (os << "(" << p.x_ << ", " << p.y_ << ")");
                }
        };
        
        // ==================================================== EllipticCurve impl
                
        typedef EllipticCurve this_t;
        typedef class EllipticCurve::Point point_t;
        
        // Initialize EC as y^2 = x^3 + ax + b
        EllipticCurve(int a, int b): a_(a),b_(b),m_table_(),table_filled_(false)
        {}

        EllipticCurve(BIGNUM* a, BIGNUM* b): a_(a),b_(b),m_table_(),table_filled_(false)
        {}

        EllipticCurve(int a, BIGNUM* b): a_(a),b_(b),m_table_(),table_filled_(false)
        {}

        EllipticCurve(BIGNUM* a, int b): a_(a),b_(b),m_table_(),table_filled_(false)
        {}

        // Calculate *all* the points (group elements) for this EC
        //NOTE: if the order of this curve is large this could take some time...
        void    CalculatePoints()
        {
            // ONLY FOR TESTING WITH SMALL INTEGERS
            int P_temp = stoi(BN_bn2dec(PRIME));
            int Px, Py;
            int x_val[P_temp];
            int y_val[P_temp];

            BIGNUM* tmp = BN_new();
            BN_CTX* ctx = BN_CTX_new();

            for ( int n = 0; n < P_temp; ++n )
            {
                int nsq = n*n;                
                BN_set_word(tmp, nsq);
                BN_mod(tmp, tmp, PRIME, ctx);
                auto elem = ((n*nsq) + a_ * n + b_) % PRIME;
                x_val[n] = stoi(BN_bn2dec( elem.i() ));
                y_val[n] = stoi(BN_bn2dec( tmp ));
            }
            
            for ( int n = 0; n < P_temp; ++n )
            {
                for ( int m = 0; m < P_temp; ++m )
                {
                    if ( x_val[n] == y_val[m] )
                    {
                        m_table_.push_back(Point(n,m,*this));
                    }
                }
            }
            
            table_filled_ = true;
        }

        // get a point (group element) on the curve 
        Point   operator[](int n)
        {
            if ( !table_filled_ )
            {
                CalculatePoints();
            }
            
            return m_table_[n];
        }

        // number of elements in this group
        size_t  Size() const 
        {
            // if( !table_filled_ )
            // {
            //     CalculatePoints<P>();
            // } 
            return m_table_.size(); 
        }

        // the degree P of this EC
        BIGNUM*     Degree() const { return PRIME; }

        // the parameter a (as an element of Fp)
        FiniteFieldElement  a() const { return a_; }
        // the paramter b (as an element of Fp)
        FiniteFieldElement  b() const { return b_; }

        // ostream handler: print this curve in human readable form
        // template<BIGNUM* T>
        friend ostream& operator <<(ostream& os, const EllipticCurve& EllipticCurve);
        // print all the elements of the EC group
        ostream&    PrintTable(ostream &os, int columns=4);

        private:
            typedef std::vector<Point>  m_table_t;
            
            m_table_t                   m_table_;   // table of points
            FiniteFieldElement       a_;         // paramter a of the EC equation
            FiniteFieldElement       b_;         // parameter b of the EC equation
            bool    table_filled_;                  // true if the table has been calculated
   };

    // template<BIGNUM* T>
        // typename EllipticCurve::Point EllipticCurve::Point::ONE(0,0); // Identity
    
    // template<BIGNUM* T>
    ostream& operator <<(ostream& os, const EllipticCurve& EllipticCurve)
    {
        os << "y^2 (mod " << PRIME << ") = (x^3";
        if ( EllipticCurve.a_ != 0 )
        {
            os << " + " << EllipticCurve.a_ << "x";
        }
        
        if ( EllipticCurve.b_.i() != 0 )
        {
            os << " + " << EllipticCurve.b_; 
        }
        
        os << noshowpos << ") mod ( " << PRIME << ")";
        return os;
    }

    // template<BIGNUM* P>
        ostream&    EllipticCurve::PrintTable(ostream &os, int columns)
        {
            if ( table_filled_ )
            {
                int col = 0;
                typename EllipticCurve::m_table_t::iterator iter = m_table_.begin();
                for ( ; iter!=m_table_.end(); ++iter )
                {
                    os << "(" << (*iter).x_.i() << ", " << (*iter).y_.i() << ") ";
                    if ( ++col > columns )
                    {
                        os << "\n";
                        col = 0;
                    }
                }
            }
            else
            {
                os << "EllipticCurve, F_" << PRIME;
            }
            return os;
        }
}

namespace   utils
{    
    float   frand()
    {
        static float norm = 1.0f / (float)RAND_MAX;
        return (float)rand()*norm;
    }
    
    int irand(int min, int max)
    {
        return min+(int)(frand()*(float)(max-min));
    }
}

using namespace Crypto;
using namespace utils;

int main(int argc, char *argv[])
{
    function();

    typedef EllipticCurve ec_t;
    ec_t EC(1,1); // For generating the Polynomial

    cout << "The elliptic curve: " << EC << "\n";

    // calulate all the points for this curve. NOTE: in the real world this would not 
    // be a very sensible thing to do. If the period is very large this is big and slow
    EC.CalculatePoints();

    // cout << "\nPoints on the curve (i.e. the group elements):\n";
    // EC.PrintTable(cout,5);
    // cout << "\n\n";

    ec_t::Point P = EC[2]; // Need to use Group generator and raising them to a number r, 1 <= r <= p-1
    cout << "some point P = " << P << ", 2P = " << (P+P) << "\n"; 
    cout << "4P = " << (P + P + P + P) << "\n"; 

    ec_t::Point Q = EC[3];
    cout << "some point Q = " << Q << ", P+Q = " << (P+Q) << "\n"; 
    

    ec_t::Point R = P;

    R += Q;

    cout << "P += Q = P + Q = " << R << "\n";
    R = P;
    R += R;
    cout << "P += P = 2P = " << R << "\n";

    

    // // Encrytion using ECC

    // ec_t::Point G = EC[0]; // Kind of Group Generator
    // while( (G.y() == 0 || G.x() == 0) || (G.PointOrder()<2) )
    // {
    //     int n = (int)(frand()*EC.Size());
    //     G = EC[n];
    // }
    
    // cout << "G = " << G << ", order(G) is " << G.PointOrder() << "\n";

    // // Alice
    // int a = irand(1,EC.Degree()-1);
    // ec_t::Point Pa = a*G;  // public key
    // cout << "Alice' public key Pa = " << a << "*" << G << " = " << Pa << endl;    

    // // Bob
    // int b = irand(1,EC.Degree()-1);;
    // ec_t::Point Pb = b*G;  // public key       
    // cout << "Bob's  public key Pb = " << b << "*" << G << " = " << Pb << endl;    

    // int j = irand(1,EC.Degree()-1);;
    // ec_t::Point Pj = j*G;
    // cout << "Jane's public key Pj = " << j << "*" << G << " = " << Pj << endl;    

    // // Alice encrypts her message to send to Bob    
    // // NOTE: the message first has to be split up into chunks that are in the Galois field F_p that is 
    // // the domain of the EC
    // // With P quite small (like in these examples) this is a serious limitation, but in the real world 
    // // P could be very sizeable indeed, thus providing enough bits for good chunks
    // int m1 = 19;
    // int m2 = 72;

    // cout << "\n\e[1mPlain text message from Alice to Bob\e: (" << m1 << ", " << m2 << ")\n";

    // // encrypt using Bob`s key
    // ec_t::Point Pk = a*Pb;
    // ec_t::ffe_t c1( m1*Pk.x() );
    // ec_t::ffe_t c2( m2*Pk.y() );
    
    // // cout << "Pk: (" << Pk.x() << ", " << Pk.y() << ")\n";
    // // encrypted message is: Pa,c1,c2
    // cout << "\nEncrypted message from Alice to Bob = {Pa,c1,c2} = {" << Pa << ", " << c1 << ", " << c2 << "}\n";

    // Pk = b * Pa;

    // // Bob now decrypts Alice`s message, using her public key and his session integer "b" which was also used to generate his public key
    // Pk = b*Pa;
    // ec_t::ffe_t m1d = c1/Pk.x();
    // ec_t::ffe_t m2d = c2/Pk.y();

    // cout << "\nBob's decrypted message from Alice = (" << m1d << ", " << m2d << ")" << endl;

    // // Jane intercepts the message and tries to decrypt it using her key
    // Pk = j*Pa;
    // m1d = c1/Pk.x();
    // m2d = c2/Pk.y();

    // cout << "\nJane's decrypted message from Alice = (" << m1d << ", " << m2d << ")" << endl;
    
    // cout << endl;

    // return EXIT_SUCCESS;
}